var EventEmitter = require('events').EventEmitter;
var Socket = require('simple-peer');
var util = require('util');

var Spray = require('./spray.js');
var GUID = require('./guid.js');

var Messages = require('./messages');
var MJoin = Messages.MJoin;
var MOfferTicket = Messages.MOfferTicket;
var MStampedTicket = Messages.MStampedTicket;

util.inherits(Membership, EventEmitter);

/*!
 * \brief implementation of the interface at
 * \url https://github.com/justayak/network.git
 * It establishes the very first connection to the network that will be the
 * departure point of the spray protocol.
 * \param id the identifier of the peer (string)
 $ \param options the webrtc specific options
 */
function Membership(id, options){
    // #0 initialize the random peer sampling protocol
    EventEmitter.call(this);    
    this.rps = new Spray(""+id+"", options);
    this.state = 'disconnect';

    // #1 create the events
    var self = this;
    this.rps.on('bdcast-receive', function(message, socket){
        self.emit('churn', message, socket); // (TODO) change the event name
    });
    this.rps.on('connect', function(){
        if (self.state === 'disconnect'){
            self.emit('statechange', 'connect');
            self.state = 'connect'
        };
    });
    this.rps.on('disconnect', function(){
        if (self.state === 'connect' && self.rps.sockets.length()===0){
            self.emit('statechange', 'disconnect');
            self.state = 'disconnect';
        };
    });    
};

/*!
 * \brief the very first part of a connection establishment to join the network.
 * This part corresponds to the first part of the 'onStampedTicketRequest' of
 * the spray protocol.
 * \param callback a callback function taking a 'message' in argument and 
 * called when we receive the data from the stun server
 */
Membership.prototype.launch = function(callback){
    var socket = new Socket({initiator:true, trickle:false}),
        id = GUID(),
        self = this;
    socket.on('signal', function(data){
        var message = new MOfferTicket(id, data, {id: self.rps.ID});
        self.rps.pending.addSocket(socket, message);
        callback(message);
    });
    setTimeout(function(){
        if (self.rps.pending.contains({id:id})){
            self.rps.pending.removeSocket({id:id});
            socket.destroy();
        };
    }, this.rps.TIMEOUT);
};

/*!
 * \brief the second part of the connection establishment. This function is
 * called at the peer already inside the network. It corresponds to the function
 * 'onTicketRequest' of the Spray protocol
 * \param message the message generated by the launch function at the joining
 * peer
 * \param callback the function called when we receive the stamped ticket from
 * the stun server. It has a 'message' argument.
 */
Membership.prototype.answer = function(message, callback){
    var socket = new Socket({initiator:false, trickle:false}),
        id = message.id,
        ticket = message.ticket,
        peer = message.peer,
        self = this;
    socket.on('signal', function(data){
        var stampedTicket = new MStampedTicket(id, data, {id:self.rps.ID});
        self.rps.pending.addSocket(socket, stampedTicket);
        callback(stampedTicket);
    });
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        self.rps.pending.removeSocket(message);
    });
    socket.on('data', function(receivedMessage){
        self.rps.receive(receivedMessage, socket);
    });
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
    });
    socket.signal(ticket);
    setTimeout(function(){
        if (self.rps.pending.contains({id:id})){
            var socket = self.rps.pending.removeSocket({id:id});
            socket.destroy();
        };
    }, this.rps.TIMEOUT);
};

/*!
 * \brief the third part of the very first connection establishment to join the 
 * network. It corresponds to the last part of the function of
 * 'onStampedTicketRequest' of the Spray protocol.
 * \param message the message containing the stamped ticket from the contact
 * peer
 */
Membership.prototype.handshake = function(message){
    var socket = this.rps.pending.removeSocket(message),
        id = message.id,
        ticket = message.ticket,
        peer = message.peer,
        self = this;
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        self.rps.partialView.addNeighbor(peer);
        self.rps.sockets.addSocket(socket, peer);
        self.rps.join(peer); // send a join request message
    });
    socket.on('data', function(receivedMessage){
        self.rps.receive(receivedMessage, socket);
    });
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
    });
    socket.signal(ticket);
};

Membership.prototype.ready = function(callback){
    if (this.rps.partialView.length() > 0){ callback(); };
};


/*!
 * \brief leave the network
 */
Membership.prototype.disconnect = function(){
    // #A clean the partial view
    for (var i = 0; i < this.rps.partialView.length(); ++i){
        var socket = this.rps.sockets.getSocket(
            this.rps.partialView.array.arr[i]);
        socket.destroy();
    };
    this.rps.partialView.array.arr.splice(0, this.rps.partialView.length());
    // #B clean the forward routes
    for (var i = 0; i < this.rps.forwards.length(); ++i){
        var socket = this.rps.forwards.array.arr[i].socket;
        socket.close();
    };
    this.rps.forwards.array.arr.splice(0,this.rps.forwards.length());
    // #C clean inview ? (TODO)
};

module.exports = Membership;
